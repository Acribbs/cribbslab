"""===========================
Pipeline gat
===========================

Overview
========

This pipeline performs gat enrichment over ChromHMM output and can be used to
annoate each of the chromatin states.
  
Usage
=====



Configuration
-------------

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_gat.py config

Input files
-----------

None required except the pipeline configuration files.

Requirements
------------

Pipeline output
===============

Output is a heatmap of the annotateion states mapped to each chromHMM state.


Code
====

"""
import sys
import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib
from pylab import savefig
from ruffus import *
import cgatcore.pipeline as P
import cgatcore.experiment as E

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])


SEQUENCESUFFIXES = ("*.bed.gz")

BEDTARGET = tuple([os.path.join(".", suffix_name)
                       for suffix_name in SEQUENCESUFFIXES])


@follows(mkdir("bed_segments.dir"))
@split(PARAMS['chromhmm_segment_bed'],
           "bed_segments.dir/*.bed")
def segment_bed(infile, outfiles):
    """Will segment the output chromHMM bed file 
    into seperate segmented bed files so that gat can be ran"""

    df = pd.read_table("JMJD3_J4_10_segments.bed", header=None)
    for index, table in df.groupby(3):
        name = "bed_segments.dir/" + index + "_segments.bed"
        table.to_csv(name, index=False, sep="\t", header=False)

@transform(segment_bed,
           suffix(".bed"),
           ".out")
def run_gat(infile, outfile):
    '''run GAT over the split segments for the bed files.'''

    bed_name = infile.replace("bed_segments.dir/", "")
    bed_name = bed_name.replace("_segments.bed", "")
    contig = PARAMS["gat_contig"]
    annotations = PARAMS['gat_annotation_bed']

    statement = '''gat-run.py --segments=%(infile)s --annotations=%(annotations)s --workspace=%(contig)s --log=%(contig)sgta.log > %(outfile)s'''

    P.run(statement, job_condaenv="gat")


@merge(run_gat, "bed_segments.dir/merged_gat.csv")
def merge_gat(infiles, outfile):
    """This function collects the log2 fold change values from gat and then merges them into a single csv file"""

    
    data_frame = pd.DataFrame()

    for infile in infiles:
        df = pd.read_table(infile)
        basename = os.path.basename(infile)
        name = basename.replace("_segments.out", "")
        annotation = df['annotation']
        data = df['l2fold']
        data = data.rename(name)
        data_frame = data_frame.append(data)
    data_frame = data_frame.append(annotation)
    data_frame = data_frame.transpose()
    data_frame = data_frame.set_index(annotation)
    del data_frame['annotation']
    data_frame.to_csv(outfile)

@transform(merge_gat,
           suffix(".csv"),
           "\1.final")
def plot_heat(infile, outfile):
    """Generates a heatmap of the merged data from gat"""

    comb = pd.read_csv(infile)
    comb = pd.read_csv("bed_segments.dir/merged_gat.csv")
    comb.set_index("annotation", inplace=True)
    df = comb.transpose()

    fig = sns.heatmap(df, annot=False, fmt="g", cmap='BuGn_r', square=True)
    figure = fig.get_figure()    
    figure.savefig(outfile, dpi=400)
    
@follows(merge_gat)
def full():
    pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
